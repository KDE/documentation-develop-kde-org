---
title: Kirigami with Rust
weight: 3
group: setup
description: >
  Create your first Kirigami application with Rust
aliases:
  - /docs/getting-started/kirigami/setup-rust/
---

## Installing Kirigami

Before getting started, we will need to install Kirigami and Rust on our machine.

{{< installpackage
  arch="cargo cmake extra-cmake-modules kirigami breeze qqc2-desktop-style"
  opensuse="cargo cmake kf6-extra-cmake-modules kf6-kirigami-devel qt6-quickcontrols2-devel kf6-qqc2-desktop-style"
  fedora="cargo cmake extra-cmake-modules kf6-kirigami2-devel kf6-qqc2-desktop-style" >}}

Further information for other distributions can be found in [Installing build dependencies](/docs/getting-started/building/help-dependencies).

## Project structure

First we create our project folder (you can use the commands below). We are going to call ours `kirigami_rust/`. This will be the project's structure:

```
kirigami_rust/
â”œâ”€â”€ CMakeLists.txt
â”œâ”€â”€ Cargo.toml
â”œâ”€â”€ build.rs
â”œâ”€â”€ org.kde.kirigami_rust.desktop
â””â”€â”€ src/
    â”œâ”€â”€ main.rs
    â””â”€â”€ qml/
        â””â”€â”€ Main.qml
```

This project will use CMake to call Cargo, which in turn will build the project.

{{< alert title="About CMake and Cargo" color="info" >}}

This is **not** the traditional way of building a Rust project: technically, only Cargo is needed to build it, usually with `cargo build` and `cargo run`.

For desktop applications however, CMake (or an equivalent like [Meson](https://mesonbuild.com/) used by GNOME or [Just](https://just.systems/man/en/introduction.html) used by COSMIC) is needed to install because Cargo lacks the necessary features to install GUI desktop applications.

{{< /alert >}}

The project will be called `kirigami_rust` and it will generate an executable called `kirigami_hello`.

{{< alert title="ðŸ’¡ Tip" color="success" >}}

You can quickly create this file structure with: `mkdir -p kirigami_rust/src/qml/`.

{{< /alert >}}

### org.kde.kirigami_rust.desktop {#desktop-file}

The primary purpose of [Desktop Entry files](https://specifications.freedesktop.org/desktop-entry-spec) is to show your app on the application launcher on Linux. Another reason to have them is to have window icons on Wayland, as they are required to tell the compositor "this window goes with this icon".

It must follow a [reverse-DNS naming scheme](https://en.wikipedia.org/wiki/Reverse_domain_name_notation) followed by the `.desktop` extension such as `org.kde.kirigami_rust.desktop`:

{{< readfile file="/content/docs/getting-started/kirigami/setup-rust/org.kde.kirigami_rust.desktop" highlight="ini" >}}

### CMakeLists.txt {#cmakelists}

The `CMakeLists.txt` file is going to be used to run Cargo and to install the necessary files together with our application. It also provides certain quality of life features, such as making sure that Kirigami is installed during compilation and to signal Linux distributions to install the necessary dependencies with the application.

{{< readfile file="/content/docs/getting-started/kirigami/setup-rust/CMakeLists.txt" highlight="cmake" >}}

The first thing we do is add KDE's [Extra CMake Modules (ECM)](https://api.kde.org/ecm/manual/ecm.7.html) to our project so we can use [ecm_find_qml_module](https://api.kde.org/ecm/module/ECMFindQmlModule.html) to check that Kirigami is installed when trying to build the application, and if it's not, fail immediately. Another useful ECM feature is [ECMUninstallTarget](https://api.kde.org/ecm/module/ECMUninstallTarget.html), which allows to easily uninstall the application with CMake if desired.

We also use CMake's [find_package()](https://cmake.org/cmake/help/latest/command/find_package.html) to make sure we have [qqc2-desktop-style](https://invent.kde.org/frameworks/qqc2-desktop-style), KDE's QML style for the desktop. This is one of the two reasons we use CMake in this tutorial.

Typically Rust projects are built with Cargo, and it won't be different here. We create a target that will simply run Cargo when run, and mark it with `ALL` so it builds by default. Cargo will build the executable inside CMake's binary directory (typically `build/`).

For more information about CMake, targets, and the binary directory, see [Building KDE software manually](/docs/getting-started/building/cmake-build).

After this, we simply install the `kirigami_rust` executable generated by Cargo in the binary directory and install it to the `BINDIR`, which is usually `/usr/bin`, `/usr/local/bin` or `~/.local/bin`. We also install the necessary desktop file to `APPDIR`, which is usually `/usr/share/applications` or `~/.local/share/applications`. This is the second reason we use CMake in this tutorial.

For more information about where KDE software is installed, see [Building KDE software manually: The install step](/docs/getting-started/building/cmake-build/#install).

Now that CMake has been taken care of, let's look at the files we are going to spend the majority of our time working with.

### Cargo.toml {#cargo-toml}

Next we have a very straightforward `Cargo.toml`:

{{< readfile file="/docs/getting-started/kirigami/setup-rust/Cargo.toml" highlight="toml" >}}

It consists of project metadata and a list of dependencies that will be pulled automatically by Cargo, namely `cxx` and `cxx-qt`, which are necessary to run Qt applications written in Rust.

### build.rs {#build-rs}

Where in C++ you'd typically register QML elements with [QML_ELEMENT](https://doc.qt.io/qt-6/qtqml-cppintegration-definetypes.html) and [ecm_add_qml_module](https://api.kde.org/ecm/module/ECMQmlModule.html) using [declarative registration](https://www.qt.io/blog/qml-type-registration-in-qt-5.15), with Rust you'll need to declare it in a [build script build.rs](https://doc.rust-lang.org/cargo/reference/build-scripts.html) file:

{{< readfile file="/docs/getting-started/kirigami/setup-rust/build.rs" highlight="rust" >}}

This is necessary to make the QML file available in the entrypoint for our application, `main.rs`.

### src/main.rs {#main-rs}

The file `kirigami_rust/src/main.rs` initializes the project and then loads the QML file, which will consist of the user interface for the application.

{{< readfile file="/content/docs/getting-started/kirigami/setup-rust/src/main.rs" highlight="rust" emphasize="12-13 17 28-30" >}}

The first part that is marked with the [#[cxx_qt::bridge]](https://kdab.github.io/cxx-qt/book/bridge/index.html) Rust macro just creates a dummy QObject out of a dummy Rust struct. This is needed just to complete the use of [QmlModule](https://docs.rs/cxx-qt-build/latest/cxx_qt_build/struct.QmlModule.html) in the previous build script `build.rs`. This will play a larger part in a future tutorial teaching how to expose Rust code to QML, but for now you can ignore it.

After this starts the important part:

Lines 12-13 import the needed Qt libraries exposed through cxx-qt.

We first create a new instance of a `QApplication`, then perform a few integrations in lines 20-26.

Then comes the part that actually creates the application window:

{{< readfile file="/content/docs/getting-started/kirigami/setup-rust/src/main.rs" highlight="rust" start=28 lines=3 >}}

The long URL `qrc:/qt/qml/org/kde/tutorial/src/qml/Main.qml` corresponds to the `Main.qml` file according to the [Qt Resource System](https://doc.qt.io/qt-6/resources.html), and it follows this scheme: `<resource_prefix><import_URI><QML_dir><file>`.

In other words: the default resource prefix `qrc:/qt/qml/` + the import URI `org/kde/tutorial` (set in `build.rs`, separated by slashes instead of dots) + the QML dir `src/qml/` + the QML file `Main.qml`.

### src/qml/Main.qml {#main-qml}

{{< readfile file="/content/docs/getting-started/kirigami/setup-rust/src/qml/Main.qml" highlight="qml" >}}

Here's where we will be handling our application's frontend.

If you know some Javascript, then much of QML will seem familiar to you (though it does have its own peculiarities). [Qt's documentation](https://doc.qt.io/qt-6/qtqml-index.html) has an extensive amount of material on this language if you feel like trying something on your own. Over the course of these tutorials we will be focusing much of our attention on our QML code, where we can use Kirigami to get the most out of it.

For now, let's focus on `Main.qml`. First we [import](https://doc.qt.io/qt-6/qtqml-syntax-imports.html) a number of important modules:

- [QtQuick](https://doc.qt.io/qt-6/qtquick-index.html), the standard library used in QML applications.
- [QtQuick Controls](https://doc.qt.io/qt-6/qtquickcontrols-index.html), which provides a number of standard controls we can use to make our applications interactive.
- [QtQuick Layouts](https://doc.qt.io/qt-6/qtquicklayouts-index.html), which provides tools for placing components within the application window.
- [Kirigami](docs:kirigami2), which provides a number of components suited for creating applications that work across devices of different shapes and sizes.

{{< alert title="Note" color="info">}}

Putting the QtQuick Controls and Kirigami imports into separate namespaces using the `as` keyword is a best practice that ensures no components with the same name can conflict. You might see different names for QtQuick Controls in the wild, such as "QQC" or "QQC2". We will be using "Controls" in this tutorial for clarity.

{{< /alert >}}

We then come to our base element, [Kirigami.ApplicationWindow](docs:kirigami2;ApplicationWindow), which provides some basic features needed for all Kirigami applications. This is the window that will contain each of our pages, the main sections of our UI.

We then set the window's `id` property to "root". IDs are useful because they let us uniquely reference a component, even if we have several of the same type.

We also set the window `title` property to "Hello World".

We then set the first page of our page stack. Most Kirigami applications are organised as a stack of pages, each page containing related components suited to a specific task. For now, we are keeping it simple, and sticking to a single page. [pageStack](docs:kirigami2;AbstractApplicationWindow::pageStack) is an initially empty stack of pages provided by [Kirigami.ApplicationWindow](docs:kirigami2;ApplicationWindow), and with `pageStack.initialPage: Kirigami.Page {...}` we set the first page presented upon loading the application to a [Kirigami.Page](docs:kirigami2;Page). This page will contain all our content.

Finally, we include in our page a [Controls.Label](docs:qtquickcontrols;QtQuick.Controls.Label) that lets us place text on our page. We use `anchors.centerIn: parent` to center our label horizontally and vertically within our parent element. In this case, the parent component of our label is [Kirigami.Page](docs:kirigami2;Page). The last thing we need to do is set its text: `text: "Hello World!"`.

## Compiling and installing the application {#build}

You should find the generated executable `kirigami_hello` under `build/debug/kirigami_hello` and you may run it directly or with `cargo run`, but it will lack a Window icon. To address this, we'll install the application first.

Run the following:

```bash
cmake -B build --install-prefix ~/.local
cmake --build build/
cmake --install build/
```

With the first command, CMake will search for Kirigami and qqc2-desktop-style.

With the second command, CMake will build the `kirigami_rust` target, which just calls `cargo build --target-dir build/`. This step will take a while to complete, but the next time you repeat the second CMake command it will be faster or you will not need to compile at all.

In the third step, CMake will install the executable `kirigami_hello` under `~/.local/bin/kirigami_hello` and the desktop file under `~/.local/share/applications`, and a new entry named "Kirigami Tutorial in Rust" will appear on your menu.

Open the menu entry and voilÃ ! Now you will see your very first Kirigami app appear before your very own eyes.

![Screenshot of the generated Kirigami application](hello-kworld.webp)

To run the new QML application in mobile mode, you can use `QT_QUICK_CONTROLS_MOBILE=1`:

```bash
QT_QUICK_CONTROLS_MOBILE=1 kirigami_hello
```

If you have compiled the project manually with CMake and for some reason you'd like to uninstall the project, you can run:

```bash
cmake --build build/ --target uninstall
```

